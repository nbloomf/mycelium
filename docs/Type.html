<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Types</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="style.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">Types</h1>
</header>
<p>So far we’ve defined a grammar of <a href="./Expr.html"><em>lambda expressions</em></a> and thought very hard about how to perform substitutions on them. In this module we’ll develop a grammar of <em>types</em>, with an eye toward implementing a Hindley-Milner style type inference algorithm.</p>
<p>Inductively defined expression grammars (like <code>Expr</code>) generate a set of expressible expressions. Type systems make it possible to impose additional restrictions on which of these expressible expressions are <em>meaningful</em>; a type system assigns a <em>type</em> to some subset of expressions. Verifying that a given expression has a certain type or that two expressions have the same type is called <em>type checking</em>, and this check can help prevent or even rule out some classes of semantic errors.</p>
<p>That’s the good news about types. The bad news is that if a type system is ad-hoc, bolted on, or otherwise poorly thought out then it will need lots of hand-holding to work properly.</p>
<p>Lambda calculus with let expressions has a type system with the following nice properties:</p>
<ol type="1">
<li>Every lambda expression can be efficiently assigned a type (or found to be untypeable).</li>
<li>The type of an expression can be <em>inferred</em> without requiring any explicit type annotations.</li>
</ol>
<p>That second property in particular, type inference, is a killer feature. It means we can get the benefits of strong, strict, static types without any syntactic overhead. This is the gist of the famous <a href="https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system"><em>Hindley-Milner type system</em></a> that underlies ML-family programming languages.</p>
<p>But before we can think about inference, we have to nail down a grammar of types.</p>
<p>As usual we start with some module imports.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE LambdaCase, FlexibleInstances #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">module</span> <span class="dt">Type</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">  ( difference, fromSet, elems, fromList, toList )</a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="kw">import</span> <span class="dt">Data.Proxy</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  ( <span class="dt">Proxy</span>(<span class="fu">..</span>) )</a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Set</span> <span class="kw">as</span> <span class="dt">S</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">  ( <span class="dt">Set</span>(<span class="fu">..</span>), empty, singleton, delete, insert, toList</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">  , member, union, unions, disjoint, fromList, difference )</a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="kw">import</span> <span class="dt">Test.QuickCheck</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12">  ( <span class="dt">Arbitrary</span>(<span class="fu">..</span>), <span class="dt">Gen</span>, elements, oneof, getSize )</a>
<a class="sourceLine" id="cb1-13" data-line-number="13"></a>
<a class="sourceLine" id="cb1-14" data-line-number="14"><span class="kw">import</span> <span class="dt">Var</span></a>
<a class="sourceLine" id="cb1-15" data-line-number="15"><span class="kw">import</span> <span class="dt">Sub</span></a>
<a class="sourceLine" id="cb1-16" data-line-number="16"><span class="kw">import</span> <span class="dt">Expr</span></a></code></pre></div>
<h2 id="monotypes">Monotypes</h2>
<p>Types come in two flavors: <em>monotypes</em> and <em>polytypes</em>; the difference between the two is roughly that polytypes have explicitly quantified bound variables while monotypes do not. This makes it possible to force all quantifiers to appear at the “top level” of a type expression, which is important in the proof that type inference is decidable. But we don’t need to worry about the details of that.</p>
<p>There are essentially 4 different kinds of monotypes.</p>
<ol type="1">
<li><strong>Type constants</strong>, which represent a specific, concrete type.</li>
<li><strong>Type variables</strong>, which in practice will always be universally quantified, but in the context of monotypes can be thought of as free.</li>
<li><strong>Arrow types</strong>, typically notated <span class="math inline">\(\alpha \rightarrow \beta\)</span>, which represent functions.</li>
<li><strong>Type constructors</strong>, which are sort of like functions at the type level. This is the mechanism for wrapping multiple types into one “structure”.</li>
</ol>
<p>We’ll represent these with the following Haskell type. Again note the complication of an extra <code>Loc</code> parameter; this will be used later.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">MonoType</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">TCon</span> <span class="dt">Loc</span> (<span class="dt">Con</span> <span class="dt">MonoType</span>)</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  <span class="fu">|</span> <span class="dt">TVar</span> <span class="dt">Loc</span> (<span class="dt">Var</span> <span class="dt">MonoType</span>)</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  <span class="fu">|</span> <span class="dt">TArr</span> <span class="dt">Loc</span> <span class="dt">MonoType</span> <span class="dt">MonoType</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">  <span class="fu">|</span> <span class="dt">TSt1</span> <span class="dt">Loc</span> (<span class="dt">Con</span> <span class="dt">MonoType</span>) <span class="dt">MonoType</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  <span class="fu">|</span> <span class="dt">TSt2</span> <span class="dt">Loc</span> (<span class="dt">Con</span> <span class="dt">MonoType</span>) <span class="dt">MonoType</span> <span class="dt">MonoType</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  <span class="kw">deriving</span> (<span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb2-8" data-line-number="8"></a>
<a class="sourceLine" id="cb2-9" data-line-number="9"><span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">MonoType</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-10" data-line-number="10">  m1 <span class="fu">==</span> m2 <span class="fu">=</span> <span class="kw">case</span> (m1,m2) <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11">    (<span class="dt">TCon</span> _ c1, <span class="dt">TCon</span> _ c2) <span class="ot">-&gt;</span> c1 <span class="fu">==</span> c2</a>
<a class="sourceLine" id="cb2-12" data-line-number="12">    (<span class="dt">TVar</span> _ x1, <span class="dt">TVar</span> _ x2) <span class="ot">-&gt;</span> x1 <span class="fu">==</span> x2</a>
<a class="sourceLine" id="cb2-13" data-line-number="13">    (<span class="dt">TArr</span> _ u1 v1, <span class="dt">TArr</span> _ u2 v2) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb2-14" data-line-number="14">      (u1 <span class="fu">==</span> u2) <span class="fu">&amp;&amp;</span> (v1 <span class="fu">==</span> v2)</a>
<a class="sourceLine" id="cb2-15" data-line-number="15">    (<span class="dt">TSt1</span> _ c1 u1, <span class="dt">TSt1</span> _ c2 u2) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb2-16" data-line-number="16">      (c1 <span class="fu">==</span> c2) <span class="fu">&amp;&amp;</span> (u1 <span class="fu">==</span> u2)</a>
<a class="sourceLine" id="cb2-17" data-line-number="17">    (<span class="dt">TSt2</span> _ c1 u1 v1, <span class="dt">TSt2</span> _ c2 u2 v2) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb2-18" data-line-number="18">      (c1 <span class="fu">==</span> c2) <span class="fu">&amp;&amp;</span> (u1 <span class="fu">==</span> u2) <span class="fu">&amp;&amp;</span> (v1 <span class="fu">==</span> v2)</a>
<a class="sourceLine" id="cb2-19" data-line-number="19">    _ <span class="ot">-&gt;</span> <span class="dt">False</span></a></code></pre></div>
<p>We’ve altered the usual type grammar slightly. The full development of HM type inference allows for type constructors of arbitrary arity, but we’re restricting ourselves to just two: <code>TSt1</code> and <code>TSt2</code>.</p>
<p>Our <code>Eq</code> instance is almost syntactic equality, except that we disregard the <code>loc</code> parameters. This is safe because monotypes have no binding constructs, so there’s no alpha equivalence to worry about.</p>
<p>Monotypes also have a notion of free variables – although it’s a boring one since <em>all</em> variables in a monotype are free. We will be finding the free type variables of other objects so we’ll wrap this in a type class (as we did with expression variables).</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">class</span> <span class="dt">FreeTypeVars</span> t <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="ot">  freeTypeVars ::</span> t <span class="ot">-&gt;</span> <span class="dt">S.Set</span> (<span class="dt">Var</span> <span class="dt">MonoType</span>)</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">FreeTypeVars</span> <span class="dt">MonoType</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">  freeTypeVars x <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    <span class="dt">TCon</span> _ _ <span class="ot">-&gt;</span> S.empty</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">    <span class="dt">TVar</span> _ x <span class="ot">-&gt;</span> S.singleton x</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">    <span class="dt">TArr</span> _ a b <span class="ot">-&gt;</span> S.union (freeTypeVars a) (freeTypeVars b)</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">    <span class="dt">TSt1</span> _ _ a <span class="ot">-&gt;</span> freeTypeVars a</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">    <span class="dt">TSt2</span> _ _ a b <span class="ot">-&gt;</span> S.union (freeTypeVars a) (freeTypeVars b)</a></code></pre></div>
<p>While we’re here, we also need an <code>Arbitrary</code> instance for generating <code>MonoType</code>s. This generator is very similar to the one we defined for <code>Expr</code>s; we keep track of a depth parameter and make sure it shrinks on every recursive call.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">MonoType</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  arbitrary <span class="fu">=</span> getSize <span class="fu">&gt;&gt;=</span> genDepth</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="ot">      genDepth ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> <span class="dt">MonoType</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">      genDepth k</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">        <span class="fu">|</span> k <span class="fu">&lt;=</span> <span class="dv">0</span> <span class="fu">=</span> oneof</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">            [ <span class="dt">TCon</span> <span class="fu">&lt;$&gt;</span> arbitrary <span class="fu">&lt;*&gt;</span> arbitrary</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">            , <span class="dt">TVar</span> <span class="fu">&lt;$&gt;</span> arbitrary <span class="fu">&lt;*&gt;</span> arbitrary</a>
<a class="sourceLine" id="cb4-9" data-line-number="9">            ]</a>
<a class="sourceLine" id="cb4-10" data-line-number="10">        <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-11" data-line-number="11">            <span class="kw">let</span> recur <span class="fu">=</span> genDepth <span class="fu">=&lt;&lt;</span> elements [<span class="dv">0</span><span class="fu">..</span>(k<span class="fu">-</span><span class="dv">1</span>)]</a>
<a class="sourceLine" id="cb4-12" data-line-number="12">            oneof</a>
<a class="sourceLine" id="cb4-13" data-line-number="13">              [ <span class="dt">TArr</span> <span class="fu">&lt;$&gt;</span> arbitrary <span class="fu">&lt;*&gt;</span> recur <span class="fu">&lt;*&gt;</span> recur</a>
<a class="sourceLine" id="cb4-14" data-line-number="14">              , <span class="dt">TSt1</span> <span class="fu">&lt;$&gt;</span> arbitrary <span class="fu">&lt;*&gt;</span> arbitrary <span class="fu">&lt;*&gt;</span> recur</a>
<a class="sourceLine" id="cb4-15" data-line-number="15">              , <span class="dt">TSt2</span> <span class="fu">&lt;$&gt;</span> arbitrary <span class="fu">&lt;*&gt;</span> arbitrary <span class="fu">&lt;*&gt;</span> recur <span class="fu">&lt;*&gt;</span> recur</a>
<a class="sourceLine" id="cb4-16" data-line-number="16">              ]</a>
<a class="sourceLine" id="cb4-17" data-line-number="17"></a>
<a class="sourceLine" id="cb4-18" data-line-number="18">  shrink <span class="fu">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb4-19" data-line-number="19">    <span class="dt">TCon</span> _ _ <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb4-20" data-line-number="20">    <span class="dt">TVar</span> _ _ <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb4-21" data-line-number="21">    <span class="dt">TArr</span> loc a b <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb4-22" data-line-number="22">      [ a, b ] <span class="fu">++</span></a>
<a class="sourceLine" id="cb4-23" data-line-number="23">      [ <span class="dt">TArr</span> loc u v <span class="fu">|</span> u <span class="ot">&lt;-</span> shrink a, v <span class="ot">&lt;-</span> shrink b ] <span class="fu">++</span></a>
<a class="sourceLine" id="cb4-24" data-line-number="24">      [ <span class="dt">TArr</span> loc a v <span class="fu">|</span> v <span class="ot">&lt;-</span> shrink b ] <span class="fu">++</span></a>
<a class="sourceLine" id="cb4-25" data-line-number="25">      [ <span class="dt">TArr</span> loc u b <span class="fu">|</span> u <span class="ot">&lt;-</span> shrink a ]</a>
<a class="sourceLine" id="cb4-26" data-line-number="26">    <span class="dt">TSt1</span> loc c a <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb4-27" data-line-number="27">      [ a ] <span class="fu">++</span></a>
<a class="sourceLine" id="cb4-28" data-line-number="28">      [ <span class="dt">TSt1</span> loc c u <span class="fu">|</span> u <span class="ot">&lt;-</span> shrink a ]</a>
<a class="sourceLine" id="cb4-29" data-line-number="29">    <span class="dt">TSt2</span> loc c a b <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb4-30" data-line-number="30">      [ a, b ] <span class="fu">++</span></a>
<a class="sourceLine" id="cb4-31" data-line-number="31">      [ <span class="dt">TSt2</span> loc c u v <span class="fu">|</span> u <span class="ot">&lt;-</span> shrink a, v <span class="ot">&lt;-</span> shrink b ] <span class="fu">++</span></a>
<a class="sourceLine" id="cb4-32" data-line-number="32">      [ <span class="dt">TSt2</span> loc c a v <span class="fu">|</span> v <span class="ot">&lt;-</span> shrink b ] <span class="fu">++</span></a>
<a class="sourceLine" id="cb4-33" data-line-number="33">      [ <span class="dt">TSt2</span> loc c u b <span class="fu">|</span> u <span class="ot">&lt;-</span> shrink a ]</a>
<a class="sourceLine" id="cb4-34" data-line-number="34"></a>
<a class="sourceLine" id="cb4-35" data-line-number="35"><span class="kw">instance</span> <span class="dt">Arbitrary</span> (<span class="dt">Var</span> <span class="dt">MonoType</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-36" data-line-number="36">  arbitrary <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-37" data-line-number="37">    <span class="kw">let</span> makeVar i <span class="fu">=</span> <span class="dt">Var</span> <span class="fu">$</span> <span class="ch">&#39;x&#39;</span> <span class="fu">:</span> show i</a>
<a class="sourceLine" id="cb4-38" data-line-number="38">    k <span class="ot">&lt;-</span> getSize</a>
<a class="sourceLine" id="cb4-39" data-line-number="39">    makeVar <span class="fu">&lt;$&gt;</span> elements [<span class="dv">0</span><span class="fu">..</span>k]</a>
<a class="sourceLine" id="cb4-40" data-line-number="40"></a>
<a class="sourceLine" id="cb4-41" data-line-number="41"><span class="kw">instance</span> <span class="dt">Arbitrary</span> (<span class="dt">Con</span> <span class="dt">MonoType</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-42" data-line-number="42">  arbitrary <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-43" data-line-number="43">    <span class="kw">let</span> makeCon i <span class="fu">=</span> <span class="dt">Con</span> <span class="fu">$</span> <span class="ch">&#39;C&#39;</span> <span class="fu">:</span> show i</a>
<a class="sourceLine" id="cb4-44" data-line-number="44">    k <span class="ot">&lt;-</span> getSize</a>
<a class="sourceLine" id="cb4-45" data-line-number="45">    makeCon <span class="fu">&lt;$&gt;</span> elements [<span class="dv">0</span><span class="fu">..</span>k]</a></code></pre></div>
<h2 id="monotype-substitutions">Monotype Substitutions</h2>
<p>As with expression substitutions, we’ll be making monotype substitutions on several kinds of objects. Let’s wrap this substitution behind a type class.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">class</span> <span class="dt">SubMono</span> t <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="ot">  ($.) ::</span> <span class="dt">Sub</span> <span class="dt">MonoType</span> <span class="ot">-&gt;</span> t <span class="ot">-&gt;</span> t</a></code></pre></div>
<p>We also need an <code>Arbitrary</code> instance for <code>MonoType</code> substitutions.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Arbitrary</span> (<span class="dt">Sub</span> <span class="dt">MonoType</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  arbitrary <span class="fu">=</span> <span class="dt">Sub</span> <span class="fu">&lt;$&gt;</span> arbitrary</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  shrink (<span class="dt">Sub</span> m) <span class="fu">=</span> map <span class="dt">Sub</span> <span class="fu">$</span> shrink m</a></code></pre></div>
<p>The most basic kind of monotype substitution is on a <code>MonoType</code> expression. This substitution is particularly simple because <code>MonoType</code>s have no bound variables.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">SubMono</span> <span class="dt">MonoType</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  s <span class="fu">$.</span> t <span class="fu">=</span> <span class="kw">case</span> t <span class="kw">of</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">    <span class="dt">TCon</span> loc c <span class="ot">-&gt;</span> <span class="dt">TCon</span> loc c</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    <span class="dt">TVar</span> loc x <span class="ot">-&gt;</span> <span class="kw">case</span> applySub x s <span class="kw">of</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">TVar</span> loc x</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">      <span class="dt">Just</span> t&#39; <span class="ot">-&gt;</span> t&#39;</a>
<a class="sourceLine" id="cb7-7" data-line-number="7">    <span class="dt">TArr</span> loc a b <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">      <span class="dt">TArr</span> loc (s <span class="fu">$.</span> a) (s <span class="fu">$.</span> b)</a>
<a class="sourceLine" id="cb7-9" data-line-number="9">    <span class="dt">TSt1</span> loc c a <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb7-10" data-line-number="10">      <span class="dt">TSt1</span> loc c (s <span class="fu">$.</span> a)</a>
<a class="sourceLine" id="cb7-11" data-line-number="11">    <span class="dt">TSt2</span> loc c a b <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb7-12" data-line-number="12">      <span class="dt">TSt2</span> loc c (s <span class="fu">$.</span> a) (s <span class="fu">$.</span> b)</a></code></pre></div>
<p>Because <code>MonoType</code>s have no bound variables, monotype substitutions also have no bound variables. The set of free type variables in a substitution is the union of the free variable sets of its images.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">FreeTypeVars</span> (<span class="dt">Sub</span> <span class="dt">MonoType</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  freeTypeVars (<span class="dt">Sub</span> m) <span class="fu">=</span> S.unions <span class="fu">.</span> map freeTypeVars <span class="fu">.</span> M.elems <span class="fu">$</span> m</a></code></pre></div>
<p>As with expression substitutions, we can substitute one monotype expression into another:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">SubMono</span> (<span class="dt">Sub</span> <span class="dt">MonoType</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  s1 <span class="fu">$.</span> (<span class="dt">Sub</span> m2) <span class="fu">=</span> <span class="dt">Sub</span> <span class="fu">$</span> fmap (s1 <span class="fu">$.</span>) m2</a></code></pre></div>
<p>And use this to make the set of monotype substitutions a monoid.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Semigroup</span> (<span class="dt">Sub</span> <span class="dt">MonoType</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  s1 <span class="fu">&lt;&gt;</span> s2 <span class="fu">=</span> (s1 <span class="fu">$.</span> s2) <span class="fu">.&amp;</span> s1</a>
<a class="sourceLine" id="cb10-3" data-line-number="3"></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Sub</span> <span class="dt">MonoType</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5">  mempty <span class="fu">=</span> emptySub</a></code></pre></div>
<p>So <code>Sub MonoType</code> is a monoid; in fact <code>$.</code> should be a monoid action of <code>Sub MonoType</code> on <code>t</code>.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1">test_submono_identity</a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="ot">  ::</span> (<span class="dt">Arbitrary</span> t, <span class="dt">SubMono</span> t, <span class="dt">Eq</span> t)</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  <span class="ot">=&gt;</span> <span class="dt">Proxy</span> t <span class="ot">-&gt;</span> t <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">test_submono_identity _ t <span class="fu">=</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">  t <span class="fu">==</span> mempty <span class="fu">$.</span> t</a>
<a class="sourceLine" id="cb11-6" data-line-number="6"></a>
<a class="sourceLine" id="cb11-7" data-line-number="7">test_submono_action</a>
<a class="sourceLine" id="cb11-8" data-line-number="8"><span class="ot">  ::</span> (<span class="dt">Arbitrary</span> t, <span class="dt">SubMono</span> t, <span class="dt">Eq</span> t)</a>
<a class="sourceLine" id="cb11-9" data-line-number="9">  <span class="ot">=&gt;</span> <span class="dt">Proxy</span> t <span class="ot">-&gt;</span> <span class="dt">Sub</span> <span class="dt">MonoType</span> <span class="ot">-&gt;</span> <span class="dt">Sub</span> <span class="dt">MonoType</span> <span class="ot">-&gt;</span> t <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb11-10" data-line-number="10">test_submono_action _ s1 s2 t <span class="fu">=</span></a>
<a class="sourceLine" id="cb11-11" data-line-number="11">  (s1 <span class="fu">$.</span> (s2 <span class="fu">$.</span> t)) <span class="fu">==</span> ((s1 <span class="fu">&lt;&gt;</span> s2) <span class="fu">$.</span> t)</a></code></pre></div>
<p>We also need a helper for detecting when a type substitution is trivial.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">trivialMonoTypeSub ::</span> <span class="dt">Sub</span> <span class="dt">MonoType</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">trivialMonoTypeSub (<span class="dt">Sub</span> m) <span class="fu">=</span> all isId <span class="fu">$</span> M.toList m</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4"><span class="ot">    isId ::</span> (<span class="dt">Var</span> <span class="dt">MonoType</span>, <span class="dt">MonoType</span>) <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">    isId (x,e) <span class="fu">=</span> <span class="kw">case</span> e <span class="kw">of</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6">      <span class="dt">TVar</span> _ _ <span class="ot">-&gt;</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb12-7" data-line-number="7">      _ <span class="ot">-&gt;</span> <span class="dt">False</span></a></code></pre></div>
<h2 id="unification">Unification</h2>
<p>Suppose we have two types <span class="math inline">\(T_1\)</span> and <span class="math inline">\(T_2\)</span>. If we can find a substitution <span class="math inline">\(S\)</span> such that <span class="math inline">\(S \cdot T_1 = S \cdot T_2\)</span>, then we say <span class="math inline">\(S\)</span> is a <em>unifier</em> for <span class="math inline">\(T_1\)</span> and <span class="math inline">\(T_2\)</span>.</p>
<p>The existence of a unifier for two types is very special; it acts as a witness that the two expressions are “almost” the same. In general, if two types have a unifier, then they have infinitely many unifiers. This is because substitution is a monoid action; if <span class="math inline">\(S\)</span> is a unifier and <span class="math inline">\(U\)</span> an arbitrary substitution, we have <span class="math display">\[(U \ast S) \cdot T_1 = U \cdot (S \cdot T_1) = U \cdot (S \cdot T_2) = (U \ast S) \cdot T_2,\]</span> letting <span class="math inline">\(\ast\)</span> denote substitution composition.</p>
<p>Some grammars have the additional property that <em>if</em> two expressions are unifiable, then they have a unique special unifier <span class="math inline">\(M\)</span> such that <em>every</em> unifier factors through <span class="math inline">\(M\)</span>. Whenever something exists and is unique, it’s handy to give it a name. So this unique ‘minimal’ unifier of two expressions, when it exists, is called the <em>most general unifier</em> of <span class="math inline">\(E_1\)</span> and <span class="math inline">\(E_2\)</span>. Whether or not most general unifiers exist depends on the details of the grammar – and it turns out that for monotypes, MGUs do exist.</p>
<p>We can put the function which computes most general unifiers behind a type class for easy reuse.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">class</span> (<span class="dt">SubMono</span> t) <span class="ot">=&gt;</span> <span class="dt">UnifyTypes</span> t <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="ot">  unifyTypes ::</span> t <span class="ot">-&gt;</span> t <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">UnificationError</span> (<span class="dt">Sub</span> <span class="dt">MonoType</span>)</a></code></pre></div>
<p>The basic signature for a <code>unify</code>-like function should be something like <span class="math display">\[t \times t \rightarrow \mathsf{Sub}\ t,\]</span> but we need to add a complication. Given two arbitrary expressions, unification will almost certainly fail, and it will fail in one of only a few predictable ways. The <code>UnificationError</code> type enumerates these failure modes.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">data</span> <span class="dt">UnificationError</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">CannotUnify</span> <span class="dt">MonoType</span> <span class="dt">MonoType</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  <span class="fu">|</span> <span class="dt">OccursCheck</span> (<span class="dt">Var</span> <span class="dt">MonoType</span>) <span class="dt">MonoType</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">  <span class="fu">|</span> <span class="dt">VariableCapture</span> (<span class="dt">Var</span> <span class="dt">MonoType</span>)</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">  <span class="fu">|</span> <span class="dt">FreeVariableCapture</span> (<span class="dt">Var</span> <span class="dt">MonoType</span>)</a>
<a class="sourceLine" id="cb14-6" data-line-number="6">  <span class="fu">|</span> <span class="dt">BoundVariableCapture</span> (<span class="dt">Var</span> <span class="dt">MonoType</span>)</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">  <span class="fu">|</span> <span class="dt">IncompatibleSub</span></a>
<a class="sourceLine" id="cb14-8" data-line-number="8">  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a></code></pre></div>
<p>Before we define <code>unifyTypes</code> for <code>MonoType</code>, we need a utility function. <code>MonoType</code>s have no bound variables, but later we’ll need to unify things that do. So we first define <code>unifyTypesInContext</code>. This function takes two monotypes, as well as sets of variables which are taken to be bound in context for each one. We then construct a unifier substitution, as well as two substitutions representing a bijection between the sets of bound variables. This is a little more complicated than the analogous operation in <code>matchExprInContext</code> because type variable binding will happen all at once at the “top level”.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">unifyTypesInContext</a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="ot">  ::</span> (<span class="dt">MonoType</span>, <span class="dt">S.Set</span> (<span class="dt">Var</span> <span class="dt">MonoType</span>))</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  <span class="ot">-&gt;</span> (<span class="dt">MonoType</span>, <span class="dt">S.Set</span> (<span class="dt">Var</span> <span class="dt">MonoType</span>))</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">  <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">UnificationError</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">       (<span class="dt">Sub</span> <span class="dt">MonoType</span>, (<span class="dt">Sub</span> <span class="dt">MonoType</span>, <span class="dt">Sub</span> <span class="dt">MonoType</span>))</a>
<a class="sourceLine" id="cb15-6" data-line-number="6"></a>
<a class="sourceLine" id="cb15-7" data-line-number="7">unifyTypesInContext (t1, bound1) (t2, bound2) <span class="fu">=</span> unify (t1,t2)</a>
<a class="sourceLine" id="cb15-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-9" data-line-number="9">    unify</a>
<a class="sourceLine" id="cb15-10" data-line-number="10"><span class="ot">      ::</span> (<span class="dt">MonoType</span>, <span class="dt">MonoType</span>)</a>
<a class="sourceLine" id="cb15-11" data-line-number="11">      <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">UnificationError</span></a>
<a class="sourceLine" id="cb15-12" data-line-number="12">           (<span class="dt">Sub</span> <span class="dt">MonoType</span>, (<span class="dt">Sub</span> <span class="dt">MonoType</span>, <span class="dt">Sub</span> <span class="dt">MonoType</span>))</a>
<a class="sourceLine" id="cb15-13" data-line-number="13">    unify (t1,t2) <span class="fu">=</span> <span class="kw">case</span> (t1,t2) <span class="kw">of</span></a>
<a class="sourceLine" id="cb15-14" data-line-number="14">      (<span class="dt">TCon</span> _ c1, <span class="dt">TCon</span> _ c2) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb15-15" data-line-number="15">        <span class="kw">if</span> c1 <span class="fu">==</span> c2</a>
<a class="sourceLine" id="cb15-16" data-line-number="16">          <span class="kw">then</span> <span class="dt">Right</span> (mempty, (mempty, mempty))</a>
<a class="sourceLine" id="cb15-17" data-line-number="17">          <span class="kw">else</span> <span class="dt">Left</span> <span class="fu">$</span> <span class="dt">CannotUnify</span> t1 t2</a></code></pre></div>
<p>Constant expressions unify precisely when they are identical, and in this case are unified by the empty substitution.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1">      (<span class="dt">TVar</span> _ x1, e2) <span class="ot">-&gt;</span> captureCheck x1 e2 bound1 bound2</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">      (e1, <span class="dt">TVar</span> _ x2) <span class="ot">-&gt;</span> captureCheck x2 e1 bound2 bound1</a></code></pre></div>
<p>Unifying variable expressions with arbitrary expressions requires some care, so we’ll defer this for now.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">      (<span class="dt">TArr</span> _ a1 b1, <span class="dt">TArr</span> _ a2 b2) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2">        (s1,(u1,v1)) <span class="ot">&lt;-</span> unify (a1, a2)</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">        (s2,(u2,v2)) <span class="ot">&lt;-</span> unify (s1 <span class="fu">$.</span> b1, s1 <span class="fu">$.</span> b2)</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">        <span class="kw">let</span></a>
<a class="sourceLine" id="cb17-5" data-line-number="5">          m <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb17-6" data-line-number="6">            u <span class="ot">&lt;-</span> unionSub u1 u2</a>
<a class="sourceLine" id="cb17-7" data-line-number="7">            v <span class="ot">&lt;-</span> unionSub v1 v2</a>
<a class="sourceLine" id="cb17-8" data-line-number="8">            return (u,v)</a>
<a class="sourceLine" id="cb17-9" data-line-number="9">        <span class="kw">case</span> m <span class="kw">of</span></a>
<a class="sourceLine" id="cb17-10" data-line-number="10">          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Left</span> <span class="fu">$</span> <span class="dt">IncompatibleSub</span></a>
<a class="sourceLine" id="cb17-11" data-line-number="11">          <span class="dt">Just</span> (u,v) <span class="ot">-&gt;</span> <span class="dt">Right</span> (s2 <span class="fu">&lt;&gt;</span> s1, (u,v))</a></code></pre></div>
<p>To unify arrow types, we first unify the left hand side of the arrows, apply the resulting substitution to the right hand sides and unify them, and then compose the two substitutions (in the right order). We also need to make sure the binding context bijections are compatible; this is what the <code>unionSub</code>s are doing.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1">      (<span class="dt">TSt1</span> _ c1 a1, <span class="dt">TSt1</span> _ c2 a2) <span class="ot">-&gt;</span> </a>
<a class="sourceLine" id="cb18-2" data-line-number="2">        <span class="kw">if</span> c1 <span class="fu">==</span> c2</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">          <span class="kw">then</span> unify (a1, a2)</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">          <span class="kw">else</span> <span class="dt">Left</span> <span class="fu">$</span> <span class="dt">CannotUnify</span> t1 t2</a>
<a class="sourceLine" id="cb18-5" data-line-number="5"></a>
<a class="sourceLine" id="cb18-6" data-line-number="6">      (<span class="dt">TSt2</span> _ c1 a1 b1, <span class="dt">TSt2</span> _ c2 a2 b2) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb18-7" data-line-number="7">        <span class="kw">if</span> c1 <span class="fu">==</span> c2</a>
<a class="sourceLine" id="cb18-8" data-line-number="8">          <span class="kw">then</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb18-9" data-line-number="9">            (s1,(u1,v1)) <span class="ot">&lt;-</span> unify (a1, a2)</a>
<a class="sourceLine" id="cb18-10" data-line-number="10">            (s2,(u2,v2)) <span class="ot">&lt;-</span> unify (s1 <span class="fu">$.</span> b1, s1 <span class="fu">$.</span> b2)</a>
<a class="sourceLine" id="cb18-11" data-line-number="11">            <span class="kw">let</span></a>
<a class="sourceLine" id="cb18-12" data-line-number="12">              m <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb18-13" data-line-number="13">                u <span class="ot">&lt;-</span> unionSub u1 u2</a>
<a class="sourceLine" id="cb18-14" data-line-number="14">                v <span class="ot">&lt;-</span> unionSub v1 v2</a>
<a class="sourceLine" id="cb18-15" data-line-number="15">                return (u,v)</a>
<a class="sourceLine" id="cb18-16" data-line-number="16">            <span class="kw">case</span> m <span class="kw">of</span></a>
<a class="sourceLine" id="cb18-17" data-line-number="17">              <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Left</span> <span class="fu">$</span> <span class="dt">IncompatibleSub</span></a>
<a class="sourceLine" id="cb18-18" data-line-number="18">              <span class="dt">Just</span> (u,v) <span class="ot">-&gt;</span> <span class="dt">Right</span> (s2 <span class="fu">&lt;&gt;</span> s1, (u,v))</a>
<a class="sourceLine" id="cb18-19" data-line-number="19">          <span class="kw">else</span> <span class="dt">Left</span> <span class="fu">$</span> <span class="dt">CannotUnify</span> t1 t2</a></code></pre></div>
<p>Constructor types are not very different from arrow types. If we wanted to allow constructor types with more parameters, this pattern would continue.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1">      _ <span class="ot">-&gt;</span> <span class="dt">Left</span> <span class="fu">$</span> <span class="dt">CannotUnify</span> t1 t2</a></code></pre></div>
<p>And no other pairs of monotypes unify.</p>
<p>Now to handle unifying variables. First we check that the variable is not bound, or else that both expressions consist of only a bound variable. In the second case we note the bound pair as part of the binding context bijection.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1">    captureCheck</a>
<a class="sourceLine" id="cb20-2" data-line-number="2"><span class="ot">      ::</span> <span class="dt">Var</span> <span class="dt">MonoType</span> <span class="ot">-&gt;</span> <span class="dt">MonoType</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3">      <span class="ot">-&gt;</span> <span class="dt">S.Set</span> (<span class="dt">Var</span> <span class="dt">MonoType</span>) <span class="ot">-&gt;</span> <span class="dt">S.Set</span> (<span class="dt">Var</span> <span class="dt">MonoType</span>)</a>
<a class="sourceLine" id="cb20-4" data-line-number="4">      <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">UnificationError</span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">           (<span class="dt">Sub</span> <span class="dt">MonoType</span>, (<span class="dt">Sub</span> <span class="dt">MonoType</span>, <span class="dt">Sub</span> <span class="dt">MonoType</span>))</a>
<a class="sourceLine" id="cb20-6" data-line-number="6">    captureCheck x1 e bd1 bd2 <span class="fu">=</span> <span class="kw">if</span> S.member x1 bd1</a>
<a class="sourceLine" id="cb20-7" data-line-number="7">        <span class="kw">then</span> <span class="kw">case</span> e <span class="kw">of</span></a>
<a class="sourceLine" id="cb20-8" data-line-number="8">          <span class="dt">TVar</span> _ x2 <span class="ot">-&gt;</span> <span class="kw">if</span> S.member x2 bd2</a>
<a class="sourceLine" id="cb20-9" data-line-number="9">            <span class="kw">then</span> <span class="dt">Right</span> (mempty, (x1 <span class="fu">--&gt;</span> <span class="dt">TVar</span> <span class="dt">Q</span> x2, x2 <span class="fu">--&gt;</span> <span class="dt">TVar</span> <span class="dt">Q</span> x1))</a>
<a class="sourceLine" id="cb20-10" data-line-number="10">            <span class="kw">else</span> <span class="dt">Left</span> <span class="fu">$</span> <span class="dt">FreeVariableCapture</span> x1</a>
<a class="sourceLine" id="cb20-11" data-line-number="11">          _ <span class="ot">-&gt;</span> <span class="dt">Left</span> <span class="fu">$</span> <span class="dt">VariableCapture</span> x1</a>
<a class="sourceLine" id="cb20-12" data-line-number="12">        <span class="kw">else</span> <span class="kw">if</span> S.disjoint bd2 (freeTypeVars e)</a>
<a class="sourceLine" id="cb20-13" data-line-number="13">          <span class="kw">then</span> bindVar x1 e</a>
<a class="sourceLine" id="cb20-14" data-line-number="14">          <span class="kw">else</span> <span class="dt">Left</span> <span class="fu">$</span> <span class="dt">BoundVariableCapture</span> x1</a></code></pre></div>
<p>Unifying a variable with an identical variable is achieved with the empty substitution.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1">    bindVar</a>
<a class="sourceLine" id="cb21-2" data-line-number="2"><span class="ot">      ::</span> <span class="dt">Var</span> <span class="dt">MonoType</span> <span class="ot">-&gt;</span> <span class="dt">MonoType</span></a>
<a class="sourceLine" id="cb21-3" data-line-number="3">      <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">UnificationError</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4">           (<span class="dt">Sub</span> <span class="dt">MonoType</span>, (<span class="dt">Sub</span> <span class="dt">MonoType</span>, <span class="dt">Sub</span> <span class="dt">MonoType</span>))</a>
<a class="sourceLine" id="cb21-5" data-line-number="5">    bindVar x (<span class="dt">TVar</span> _ y) <span class="fu">|</span> x <span class="fu">==</span> y <span class="fu">=</span> <span class="dt">Right</span> (mempty, (mempty, mempty))</a></code></pre></div>
<p>For any other kind of expression, we can unify as long as the variable being substituted does not also appear (free, but this is redundant) in the expression. Why is this important? Remember that unification is trying to construct an <span class="math inline">\(S\)</span> such that <span class="math inline">\(S \cdot E_1 = S \cdot E_2\)</span>. If <span class="math inline">\(E_1 = x\)</span>, and if <span class="math inline">\(x\)</span> is free in <span class="math inline">\(E_2\)</span> but <span class="math inline">\(E_2 \neq x\)</span>, then any substitution with <span class="math inline">\(x\)</span> in the support cannot possibly make these equal. We report this as an <em>occurs check</em> violation.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1">    bindVar x e <span class="fu">=</span> <span class="kw">if</span> S.member x <span class="fu">$</span> freeTypeVars e</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">      <span class="kw">then</span> <span class="dt">Left</span> <span class="fu">$</span> <span class="dt">OccursCheck</span> x e</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">      <span class="kw">else</span> <span class="dt">Right</span> (x <span class="fu">--&gt;</span> e, (mempty, mempty))</a></code></pre></div>
<p>Now we can unify <code>MonoType</code>s using <code>unifyTypesInContext</code>. In this case there is no context to worry about.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">UnifyTypes</span> <span class="dt">MonoType</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2">  unifyTypes x y <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb23-3" data-line-number="3">    (s,_) <span class="ot">&lt;-</span> unifyTypesInContext (x, S.empty) (y, S.empty)</a>
<a class="sourceLine" id="cb23-4" data-line-number="4">    return s</a></code></pre></div>
<p>And that’s it for monotype unification. We can check that the substitution found by <code>unify</code> satisfies the equation <span class="math inline">\(S \cdot E_1 = S \cdot E_2\)</span> with a property test.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1">test_unify_eq</a>
<a class="sourceLine" id="cb24-2" data-line-number="2"><span class="ot">  ::</span> (<span class="dt">Eq</span> t, <span class="dt">UnifyTypes</span> t)</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">  <span class="ot">=&gt;</span> <span class="dt">Proxy</span> t <span class="ot">-&gt;</span> t <span class="ot">-&gt;</span> t <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb24-4" data-line-number="4">test_unify_eq _ t1 t2 <span class="fu">=</span> <span class="kw">case</span> unifyTypes t1 t2 <span class="kw">of</span></a>
<a class="sourceLine" id="cb24-5" data-line-number="5">  <span class="dt">Right</span> s <span class="ot">-&gt;</span> (s <span class="fu">$.</span> t1) <span class="fu">==</span> (s <span class="fu">$.</span> t2)</a>
<a class="sourceLine" id="cb24-6" data-line-number="6">  <span class="dt">Left</span> _ <span class="ot">-&gt;</span> <span class="dt">True</span></a></code></pre></div>
<p>Another property is that every expression should unify with itself via the empty substitution.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1">test_unify_self_empty</a>
<a class="sourceLine" id="cb25-2" data-line-number="2"><span class="ot">  ::</span> (<span class="dt">Eq</span> t, <span class="dt">UnifyTypes</span> t)</a>
<a class="sourceLine" id="cb25-3" data-line-number="3">  <span class="ot">=&gt;</span> <span class="dt">Proxy</span> t <span class="ot">-&gt;</span> t <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb25-4" data-line-number="4">test_unify_self_empty _ t <span class="fu">=</span> <span class="kw">case</span> unifyTypes t t <span class="kw">of</span></a>
<a class="sourceLine" id="cb25-5" data-line-number="5">  <span class="dt">Right</span> s <span class="ot">-&gt;</span> s <span class="fu">==</span> emptySub</a>
<a class="sourceLine" id="cb25-6" data-line-number="6">  <span class="dt">Left</span> _ <span class="ot">-&gt;</span> <span class="dt">False</span></a></code></pre></div>
<p>Unification should also be symmetric: <span class="math inline">\((t_1,t_2)\)</span> and <span class="math inline">\((t_2,t_1)\)</span> should either both unify or both fail to unify.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1">test_unify_symmetric</a>
<a class="sourceLine" id="cb26-2" data-line-number="2"><span class="ot">  ::</span> (<span class="dt">Eq</span> t, <span class="dt">UnifyTypes</span> t)</a>
<a class="sourceLine" id="cb26-3" data-line-number="3">  <span class="ot">=&gt;</span> <span class="dt">Proxy</span> t <span class="ot">-&gt;</span> t <span class="ot">-&gt;</span> t <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb26-4" data-line-number="4">test_unify_symmetric _ t1 t2 <span class="fu">=</span></a>
<a class="sourceLine" id="cb26-5" data-line-number="5">  <span class="kw">case</span> (unifyTypes t1 t2, unifyTypes t2 t1) <span class="kw">of</span></a>
<a class="sourceLine" id="cb26-6" data-line-number="6">    (<span class="dt">Right</span> _, <span class="dt">Right</span> _) <span class="ot">-&gt;</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb26-7" data-line-number="7">    (<span class="dt">Left</span> _, <span class="dt">Left</span> _) <span class="ot">-&gt;</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb26-8" data-line-number="8">    _ <span class="ot">-&gt;</span> <span class="dt">False</span></a></code></pre></div>
<p>Unifiability should also be “down closed”. This needs some explanation. We can impose a kind of order on monotype expressions by saying <span class="math inline">\(t_1 \leq t_2\)</span> if <span class="math inline">\(t_2 = S \cdot t_1\)</span> for some substitution. It’s not too hard to see that this order is reflexive and transitive. It may also be antisymmetric, but I’m too lazy to convince myself of that and we don’t really need it. Say two expressions <span class="math inline">\(S \cdot E_1\)</span> and <span class="math inline">\(S \cdot E_2\)</span> unify; that is, we have <span class="math inline">\(TS \cdot E_1 = TS \cdot E_2\)</span>. Then <span class="math inline">\(E_1\)</span> and <span class="math inline">\(E_2\)</span> also unify. This property is sometimes called <em>down closure</em> because in order language it says that whenever <span class="math inline">\(a_1 \leq b_1\)</span> and <span class="math inline">\(a_2 \leq b_2\)</span> and <span class="math inline">\(b_1 \sim b_2\)</span>, we also have <span class="math inline">\(a_1 \sim a_2\)</span>.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1">test_unify_down_closed</a>
<a class="sourceLine" id="cb27-2" data-line-number="2"><span class="ot">  ::</span> (<span class="dt">Eq</span> t, <span class="dt">UnifyTypes</span> t)</a>
<a class="sourceLine" id="cb27-3" data-line-number="3">  <span class="ot">=&gt;</span> <span class="dt">Proxy</span> t <span class="ot">-&gt;</span> t <span class="ot">-&gt;</span> t <span class="ot">-&gt;</span> <span class="dt">Sub</span> <span class="dt">MonoType</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb27-4" data-line-number="4">test_unify_down_closed _ t1 t2 s <span class="fu">=</span></a>
<a class="sourceLine" id="cb27-5" data-line-number="5">  <span class="kw">case</span> unifyTypes (s <span class="fu">$.</span> t1) (s <span class="fu">$.</span> t2) <span class="kw">of</span></a>
<a class="sourceLine" id="cb27-6" data-line-number="6">    <span class="dt">Left</span> _ <span class="ot">-&gt;</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb27-7" data-line-number="7">    <span class="dt">Right</span> _ <span class="ot">-&gt;</span> <span class="kw">case</span> unifyTypes t1 t2 <span class="kw">of</span></a>
<a class="sourceLine" id="cb27-8" data-line-number="8">      <span class="dt">Left</span> _ <span class="ot">-&gt;</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb27-9" data-line-number="9">      <span class="dt">Right</span> _ <span class="ot">-&gt;</span> <span class="dt">True</span></a></code></pre></div>
<h2 id="polytypes">Polytypes</h2>
<p>Now for polytypes. A <em>polytype</em> is just a monotype together with some (possibly empty) set of explicitly quantified variables. Note that there may be quantified variables that do not appear in the monotype; this is OK, and we should be able to toss out such variables without changing the meaning of the polytype.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="kw">data</span> <span class="dt">PolyType</span> <span class="fu">=</span> <span class="dt">ForAll</span> (<span class="dt">S.Set</span> (<span class="dt">Var</span> <span class="dt">MonoType</span>)) <span class="dt">MonoType</span></a>
<a class="sourceLine" id="cb28-2" data-line-number="2">  <span class="kw">deriving</span> (<span class="dt">Show</span>)</a></code></pre></div>
<p>We’ll need an <code>Arbitrary</code> instance.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">PolyType</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb29-2" data-line-number="2">  arbitrary <span class="fu">=</span> <span class="dt">ForAll</span> <span class="fu">&lt;$&gt;</span> arbitrary <span class="fu">&lt;*&gt;</span> arbitrary</a>
<a class="sourceLine" id="cb29-3" data-line-number="3"></a>
<a class="sourceLine" id="cb29-4" data-line-number="4">  shrink (<span class="dt">ForAll</span> as tau) <span class="fu">=</span></a>
<a class="sourceLine" id="cb29-5" data-line-number="5">    [ <span class="dt">ForAll</span> bs psi <span class="fu">|</span> bs <span class="ot">&lt;-</span> shrink as, psi <span class="ot">&lt;-</span> shrink tau ] <span class="fu">++</span></a>
<a class="sourceLine" id="cb29-6" data-line-number="6">    [ <span class="dt">ForAll</span> as psi <span class="fu">|</span> psi <span class="ot">&lt;-</span> shrink tau ] <span class="fu">++</span></a>
<a class="sourceLine" id="cb29-7" data-line-number="7">    [ <span class="dt">ForAll</span> bs tau <span class="fu">|</span> bs <span class="ot">&lt;-</span> shrink as ]</a></code></pre></div>
<p>And finding the free variables of a polytype is simple enough – find the free variables of the monotype, and toss out any in the quantified set.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">FreeTypeVars</span> <span class="dt">PolyType</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-2" data-line-number="2">  freeTypeVars (<span class="dt">ForAll</span> as tau) <span class="fu">=</span></a>
<a class="sourceLine" id="cb30-3" data-line-number="3">    S.difference (freeTypeVars tau) as</a></code></pre></div>
<p>Note that we didn’t derive equality for polytypes; as for expressions, syntactic equality on polytypes is too strict because it doesn’t account for alpha equivalence.</p>
<p>Actually detecting alpha equivalence is a little different for polytypes than for expressions, because the bindings all happen at the “top level”, rather than throughout the structure. Rather than just detecting whether or not two polytypes are alpha equivalent, we’ll construct an explicit pair of substitutions, called an <em>alpha witness</em>, that maps their respective monotypes to each other.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1">alphaWitness</a>
<a class="sourceLine" id="cb31-2" data-line-number="2"><span class="ot">  ::</span> <span class="dt">PolyType</span></a>
<a class="sourceLine" id="cb31-3" data-line-number="3">  <span class="ot">-&gt;</span> <span class="dt">PolyType</span></a>
<a class="sourceLine" id="cb31-4" data-line-number="4">  <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Sub</span> <span class="dt">MonoType</span>, <span class="dt">Sub</span> <span class="dt">MonoType</span>)</a>
<a class="sourceLine" id="cb31-5" data-line-number="5">alphaWitness (<span class="dt">ForAll</span> as u) (<span class="dt">ForAll</span> bs v) <span class="fu">=</span> witness (u,v)</a>
<a class="sourceLine" id="cb31-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb31-7" data-line-number="7">    witness</a>
<a class="sourceLine" id="cb31-8" data-line-number="8"><span class="ot">      ::</span> (<span class="dt">MonoType</span>, <span class="dt">MonoType</span>)</a>
<a class="sourceLine" id="cb31-9" data-line-number="9">      <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Sub</span> <span class="dt">MonoType</span>, <span class="dt">Sub</span> <span class="dt">MonoType</span>)</a>
<a class="sourceLine" id="cb31-10" data-line-number="10">    witness <span class="fu">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb31-11" data-line-number="11">      (<span class="dt">TCon</span> _ c1, <span class="dt">TCon</span> _ c2) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb31-12" data-line-number="12">        <span class="kw">if</span> c1 <span class="fu">==</span> c2</a>
<a class="sourceLine" id="cb31-13" data-line-number="13">          <span class="kw">then</span> <span class="dt">Just</span> (emptySub, emptySub)</a>
<a class="sourceLine" id="cb31-14" data-line-number="14">          <span class="kw">else</span> <span class="dt">Nothing</span></a></code></pre></div>
<p>If two constant expressions are identically equal, they are alpha equivalent via the empty substitutions.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1">      (<span class="dt">TVar</span> _ x1, <span class="dt">TVar</span> _ x2) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb32-2" data-line-number="2">        <span class="kw">case</span> (S.member x1 as, S.member x2 bs) <span class="kw">of</span></a>
<a class="sourceLine" id="cb32-3" data-line-number="3">          (<span class="dt">True</span>, <span class="dt">True</span>) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb32-4" data-line-number="4">            <span class="dt">Just</span> (x1 <span class="fu">--&gt;</span> <span class="dt">TVar</span> <span class="dt">Q</span> x2, x2 <span class="fu">--&gt;</span> <span class="dt">TVar</span> <span class="dt">Q</span> x1)</a>
<a class="sourceLine" id="cb32-5" data-line-number="5">          (<span class="dt">False</span>, <span class="dt">False</span>) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb32-6" data-line-number="6">            <span class="kw">if</span> x1 <span class="fu">==</span> x2</a>
<a class="sourceLine" id="cb32-7" data-line-number="7">              <span class="kw">then</span> <span class="dt">Just</span> (emptySub, emptySub)</a>
<a class="sourceLine" id="cb32-8" data-line-number="8">              <span class="kw">else</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb32-9" data-line-number="9">          _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a></code></pre></div>
<p>Given two variable expressions, we first check whether either is bound in its polytype. If both are bound, then they are alpha equivalent via a transposition. If both are free, they are alpha equivalent only if they are identically equal, and in this case via the empty substitutions. If one is bound and the other is free, they cannot be alpha equivalent.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1">      (<span class="dt">TArr</span> _ a1 b1, <span class="dt">TArr</span> _ a2 b2) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb33-2" data-line-number="2">        (u1,v1) <span class="ot">&lt;-</span> witness (a1,a2)</a>
<a class="sourceLine" id="cb33-3" data-line-number="3">        (u2,v2) <span class="ot">&lt;-</span> witness (b1,b2)</a>
<a class="sourceLine" id="cb33-4" data-line-number="4">        w1 <span class="ot">&lt;-</span> unionSub u1 u2</a>
<a class="sourceLine" id="cb33-5" data-line-number="5">        w2 <span class="ot">&lt;-</span> unionSub v1 v2</a>
<a class="sourceLine" id="cb33-6" data-line-number="6">        return (w1,w2)</a></code></pre></div>
<p>Given two arrow types, we first try to find an alpha witness for each end of the arrow, and then try to union them together. Remember that <code>unionSub</code> tries to union two substitutions as sets, and fails if they aren’t compatible.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1">      (<span class="dt">TSt1</span> _ c1 a1, <span class="dt">TSt1</span> _ c2 a2) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb34-2" data-line-number="2">        <span class="kw">if</span> c1 <span class="fu">==</span> c2</a>
<a class="sourceLine" id="cb34-3" data-line-number="3">          <span class="kw">then</span> witness (a1,a2)</a>
<a class="sourceLine" id="cb34-4" data-line-number="4">          <span class="kw">else</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb34-5" data-line-number="5"></a>
<a class="sourceLine" id="cb34-6" data-line-number="6">      (<span class="dt">TSt2</span> _ c1 a1 b1, <span class="dt">TSt2</span> _ c2 a2 b2) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb34-7" data-line-number="7">        <span class="kw">if</span> c1 <span class="fu">==</span> c2</a>
<a class="sourceLine" id="cb34-8" data-line-number="8">          <span class="kw">then</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb34-9" data-line-number="9">            (u1,v1) <span class="ot">&lt;-</span> witness (a1,a2)</a>
<a class="sourceLine" id="cb34-10" data-line-number="10">            (u2,v2) <span class="ot">&lt;-</span> witness (b1,b2)</a>
<a class="sourceLine" id="cb34-11" data-line-number="11">            w1 <span class="ot">&lt;-</span> unionSub u1 u2</a>
<a class="sourceLine" id="cb34-12" data-line-number="12">            w2 <span class="ot">&lt;-</span> unionSub v1 v2</a>
<a class="sourceLine" id="cb34-13" data-line-number="13">            return (w1,w2)</a>
<a class="sourceLine" id="cb34-14" data-line-number="14">          <span class="kw">else</span> <span class="dt">Nothing</span></a></code></pre></div>
<p>Type constructors are similar to arrow types, with the caveat that the constructor names have to be identical.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1">      _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a></code></pre></div>
<p>No other pairs of polytypes are alpha equivalent.</p>
<p>Now two polytypes are equal precisely when they have an alpha witness.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">PolyType</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb36-2" data-line-number="2">  p1 <span class="fu">==</span> p2 <span class="fu">=</span> <span class="kw">case</span> alphaWitness p1 p2 <span class="kw">of</span></a>
<a class="sourceLine" id="cb36-3" data-line-number="3">    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb36-4" data-line-number="4">    <span class="dt">Just</span> _ <span class="ot">-&gt;</span> <span class="dt">True</span></a></code></pre></div>
<p>Because we’re not deriving the usual syntactic equality for <code>PolyType</code>s, it’s worthwhile to make sure it makes sense. First some test cases.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="ot">test_cases_polytype_eq ::</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb37-2" data-line-number="2">test_cases_polytype_eq <span class="fu">=</span> and</a>
<a class="sourceLine" id="cb37-3" data-line-number="3">  [ (<span class="fu">/=</span>)</a>
<a class="sourceLine" id="cb37-4" data-line-number="4">      (<span class="dt">ForAll</span> S.empty (<span class="dt">TVar</span> <span class="dt">Q</span> (<span class="dt">Var</span> <span class="st">&quot;a&quot;</span>)))</a>
<a class="sourceLine" id="cb37-5" data-line-number="5">      (<span class="dt">ForAll</span> S.empty (<span class="dt">TVar</span> <span class="dt">Q</span> (<span class="dt">Var</span> <span class="st">&quot;b&quot;</span>)))</a>
<a class="sourceLine" id="cb37-6" data-line-number="6"></a>
<a class="sourceLine" id="cb37-7" data-line-number="7">  , (<span class="fu">/=</span>)</a>
<a class="sourceLine" id="cb37-8" data-line-number="8">      (<span class="dt">ForAll</span> S.empty (<span class="dt">TVar</span> <span class="dt">Q</span> (<span class="dt">Var</span> <span class="st">&quot;a&quot;</span>)))</a>
<a class="sourceLine" id="cb37-9" data-line-number="9">      (<span class="dt">ForAll</span> (S.fromList [<span class="dt">Var</span> <span class="st">&quot;a&quot;</span>]) (<span class="dt">TVar</span> <span class="dt">Q</span> (<span class="dt">Var</span> <span class="st">&quot;a&quot;</span>)))</a>
<a class="sourceLine" id="cb37-10" data-line-number="10"></a>
<a class="sourceLine" id="cb37-11" data-line-number="11">  , (<span class="fu">==</span>)</a>
<a class="sourceLine" id="cb37-12" data-line-number="12">      (<span class="dt">ForAll</span> (S.fromList [<span class="dt">Var</span> <span class="st">&quot;a&quot;</span>])</a>
<a class="sourceLine" id="cb37-13" data-line-number="13">        (<span class="dt">TArr</span> <span class="dt">Q</span> (<span class="dt">TVar</span> <span class="dt">Q</span> (<span class="dt">Var</span> <span class="st">&quot;a&quot;</span>)) (<span class="dt">TVar</span> <span class="dt">Q</span> (<span class="dt">Var</span> <span class="st">&quot;a&quot;</span>))))</a>
<a class="sourceLine" id="cb37-14" data-line-number="14">      (<span class="dt">ForAll</span> (S.fromList [<span class="dt">Var</span> <span class="st">&quot;b&quot;</span>])</a>
<a class="sourceLine" id="cb37-15" data-line-number="15">        (<span class="dt">TArr</span> <span class="dt">Q</span> (<span class="dt">TVar</span> <span class="dt">Q</span> (<span class="dt">Var</span> <span class="st">&quot;b&quot;</span>)) (<span class="dt">TVar</span> <span class="dt">Q</span> (<span class="dt">Var</span> <span class="st">&quot;b&quot;</span>))))</a>
<a class="sourceLine" id="cb37-16" data-line-number="16"></a>
<a class="sourceLine" id="cb37-17" data-line-number="17">  , (<span class="fu">/=</span>)</a>
<a class="sourceLine" id="cb37-18" data-line-number="18">      (<span class="dt">ForAll</span> (S.fromList [<span class="dt">Var</span> <span class="st">&quot;a&quot;</span>])</a>
<a class="sourceLine" id="cb37-19" data-line-number="19">        (<span class="dt">TArr</span> <span class="dt">Q</span> (<span class="dt">TVar</span> <span class="dt">Q</span> (<span class="dt">Var</span> <span class="st">&quot;a&quot;</span>)) (<span class="dt">TVar</span> <span class="dt">Q</span> (<span class="dt">Var</span> <span class="st">&quot;a&quot;</span>))))</a>
<a class="sourceLine" id="cb37-20" data-line-number="20">      (<span class="dt">ForAll</span> (S.fromList [<span class="dt">Var</span> <span class="st">&quot;b&quot;</span>])</a>
<a class="sourceLine" id="cb37-21" data-line-number="21">        (<span class="dt">TArr</span> <span class="dt">Q</span> (<span class="dt">TVar</span> <span class="dt">Q</span> (<span class="dt">Var</span> <span class="st">&quot;a&quot;</span>)) (<span class="dt">TVar</span> <span class="dt">Q</span> (<span class="dt">Var</span> <span class="st">&quot;b&quot;</span>))))</a>
<a class="sourceLine" id="cb37-22" data-line-number="22"></a>
<a class="sourceLine" id="cb37-23" data-line-number="23">  , (<span class="fu">/=</span>)</a>
<a class="sourceLine" id="cb37-24" data-line-number="24">      (<span class="dt">ForAll</span> (S.fromList [<span class="dt">Var</span> <span class="st">&quot;a&quot;</span>])</a>
<a class="sourceLine" id="cb37-25" data-line-number="25">        (<span class="dt">TArr</span> <span class="dt">Q</span> (<span class="dt">TVar</span> <span class="dt">Q</span> (<span class="dt">Var</span> <span class="st">&quot;a&quot;</span>)) (<span class="dt">TVar</span> <span class="dt">Q</span> (<span class="dt">Var</span> <span class="st">&quot;a&quot;</span>))))</a>
<a class="sourceLine" id="cb37-26" data-line-number="26">      (<span class="dt">ForAll</span> (S.fromList [<span class="dt">Var</span> <span class="st">&quot;a&quot;</span>, <span class="dt">Var</span> <span class="st">&quot;b&quot;</span>])</a>
<a class="sourceLine" id="cb37-27" data-line-number="27">        (<span class="dt">TArr</span> <span class="dt">Q</span> (<span class="dt">TVar</span> <span class="dt">Q</span> (<span class="dt">Var</span> <span class="st">&quot;a&quot;</span>)) (<span class="dt">TVar</span> <span class="dt">Q</span> (<span class="dt">Var</span> <span class="st">&quot;b&quot;</span>))))</a>
<a class="sourceLine" id="cb37-28" data-line-number="28"></a>
<a class="sourceLine" id="cb37-29" data-line-number="29">  , (<span class="fu">==</span>)</a>
<a class="sourceLine" id="cb37-30" data-line-number="30">      (<span class="dt">ForAll</span> (S.fromList [<span class="dt">Var</span> <span class="st">&quot;a&quot;</span>])</a>
<a class="sourceLine" id="cb37-31" data-line-number="31">        (<span class="dt">TSt1</span> <span class="dt">Q</span> (<span class="dt">Con</span> <span class="st">&quot;C&quot;</span>) (<span class="dt">TVar</span> <span class="dt">Q</span> (<span class="dt">Var</span> <span class="st">&quot;a&quot;</span>))))</a>
<a class="sourceLine" id="cb37-32" data-line-number="32">      (<span class="dt">ForAll</span> (S.fromList [<span class="dt">Var</span> <span class="st">&quot;b&quot;</span>])</a>
<a class="sourceLine" id="cb37-33" data-line-number="33">        (<span class="dt">TSt1</span> <span class="dt">Q</span> (<span class="dt">Con</span> <span class="st">&quot;C&quot;</span>) (<span class="dt">TVar</span> <span class="dt">Q</span> (<span class="dt">Var</span> <span class="st">&quot;b&quot;</span>))))</a>
<a class="sourceLine" id="cb37-34" data-line-number="34"></a>
<a class="sourceLine" id="cb37-35" data-line-number="35">  , (<span class="fu">/=</span>)</a>
<a class="sourceLine" id="cb37-36" data-line-number="36">      (<span class="dt">ForAll</span> (S.fromList [<span class="dt">Var</span> <span class="st">&quot;a&quot;</span>])</a>
<a class="sourceLine" id="cb37-37" data-line-number="37">        (<span class="dt">TSt1</span> <span class="dt">Q</span> (<span class="dt">Con</span> <span class="st">&quot;C&quot;</span>) (<span class="dt">TVar</span> <span class="dt">Q</span> (<span class="dt">Var</span> <span class="st">&quot;a&quot;</span>))))</a>
<a class="sourceLine" id="cb37-38" data-line-number="38">      (<span class="dt">ForAll</span> (S.fromList [<span class="dt">Var</span> <span class="st">&quot;a&quot;</span>])</a>
<a class="sourceLine" id="cb37-39" data-line-number="39">        (<span class="dt">TSt1</span> <span class="dt">Q</span> (<span class="dt">Con</span> <span class="st">&quot;D&quot;</span>) (<span class="dt">TVar</span> <span class="dt">Q</span> (<span class="dt">Var</span> <span class="st">&quot;a&quot;</span>))))</a>
<a class="sourceLine" id="cb37-40" data-line-number="40">  ]</a></code></pre></div>
<p>We can introduce a utility function to rename the bound variables of a polytype. Specifically, this function will rename the bound variables appearing in one set, avoiding names that appear in some other sets.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" data-line-number="1">renameBoundT</a>
<a class="sourceLine" id="cb38-2" data-line-number="2"><span class="ot">  ::</span> [<span class="dt">S.Set</span> (<span class="dt">Var</span> <span class="dt">MonoType</span>)]</a>
<a class="sourceLine" id="cb38-3" data-line-number="3">  <span class="ot">-&gt;</span> <span class="dt">S.Set</span> (<span class="dt">Var</span> <span class="dt">MonoType</span>)</a>
<a class="sourceLine" id="cb38-4" data-line-number="4">  <span class="ot">-&gt;</span> <span class="dt">PolyType</span></a>
<a class="sourceLine" id="cb38-5" data-line-number="5">  <span class="ot">-&gt;</span> <span class="dt">PolyType</span></a>
<a class="sourceLine" id="cb38-6" data-line-number="6">renameBoundT avoids vars t <span class="fu">=</span> foldr rename t <span class="fu">$</span> S.toList vars</a>
<a class="sourceLine" id="cb38-7" data-line-number="7">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb38-8" data-line-number="8"><span class="ot">    rename ::</span> <span class="dt">Var</span> <span class="dt">MonoType</span> <span class="ot">-&gt;</span> <span class="dt">PolyType</span> <span class="ot">-&gt;</span> <span class="dt">PolyType</span></a>
<a class="sourceLine" id="cb38-9" data-line-number="9">    rename x (<span class="dt">ForAll</span> as t) <span class="fu">=</span></a>
<a class="sourceLine" id="cb38-10" data-line-number="10">      <span class="kw">if</span> S.member x as</a>
<a class="sourceLine" id="cb38-11" data-line-number="11">        <span class="kw">then</span></a>
<a class="sourceLine" id="cb38-12" data-line-number="12">          <span class="kw">let</span> z <span class="fu">=</span> fresh <span class="fu">$</span> as <span class="fu">:</span> (freeTypeVars t) <span class="fu">:</span> avoids <span class="kw">in</span></a>
<a class="sourceLine" id="cb38-13" data-line-number="13">          <span class="dt">ForAll</span> (S.insert z <span class="fu">$</span> S.delete x as) ((x <span class="fu">--&gt;</span> <span class="dt">TVar</span> <span class="dt">Q</span> z) <span class="fu">$.</span> t)</a>
<a class="sourceLine" id="cb38-14" data-line-number="14">        <span class="kw">else</span> <span class="dt">ForAll</span> as t</a></code></pre></div>
<p>Renaming bound variables should yield an identical polytype.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb39-1" data-line-number="1">test_polytype_eq_renames</a>
<a class="sourceLine" id="cb39-2" data-line-number="2"><span class="ot">  ::</span> <span class="dt">PolyType</span> <span class="ot">-&gt;</span> [<span class="dt">S.Set</span> (<span class="dt">Var</span> <span class="dt">MonoType</span>)] <span class="ot">-&gt;</span> <span class="dt">S.Set</span> (<span class="dt">Var</span> <span class="dt">MonoType</span>) <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb39-3" data-line-number="3">test_polytype_eq_renames t avoids xs <span class="fu">=</span> and</a>
<a class="sourceLine" id="cb39-4" data-line-number="4">  [ t <span class="fu">==</span> renameBoundT avoids xs t</a>
<a class="sourceLine" id="cb39-5" data-line-number="5">  , renameBoundT avoids xs t <span class="fu">==</span> t</a>
<a class="sourceLine" id="cb39-6" data-line-number="6">  ]</a></code></pre></div>
<p>We can also apply a monotype substitution to a polytype, taking care to rename the bound variables if needed.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">SubMono</span> <span class="dt">PolyType</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb40-2" data-line-number="2">  s <span class="fu">$.</span> (<span class="dt">ForAll</span> as tau) <span class="fu">=</span></a>
<a class="sourceLine" id="cb40-3" data-line-number="3">    <span class="kw">let</span></a>
<a class="sourceLine" id="cb40-4" data-line-number="4">      s2 <span class="fu">=</span> s <span class="fu">&lt;/</span> as</a>
<a class="sourceLine" id="cb40-5" data-line-number="5">      bs <span class="fu">=</span> freeTypeVars s2</a>
<a class="sourceLine" id="cb40-6" data-line-number="6">    <span class="kw">in</span></a>
<a class="sourceLine" id="cb40-7" data-line-number="7">      <span class="kw">if</span> S.disjoint bs as</a>
<a class="sourceLine" id="cb40-8" data-line-number="8">        <span class="kw">then</span> <span class="dt">ForAll</span> as (s2 <span class="fu">$.</span> tau)</a>
<a class="sourceLine" id="cb40-9" data-line-number="9">        <span class="kw">else</span></a>
<a class="sourceLine" id="cb40-10" data-line-number="10">          <span class="kw">let</span> avoids <span class="fu">=</span> [ bs, as, freeTypeVars tau ] <span class="kw">in</span></a>
<a class="sourceLine" id="cb40-11" data-line-number="11">          s2 <span class="fu">$.</span> renameBoundT avoids as (<span class="dt">ForAll</span> as tau)</a></code></pre></div>
<p>Finally, we can unify polytypes. We rename the bound variables first to ensure that no variables are free in one polytype and bound in the other.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">UnifyTypes</span> <span class="dt">PolyType</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb41-2" data-line-number="2">  unifyTypes t1<span class="fu">@</span>(<span class="dt">ForAll</span> bs1 _) t2<span class="fu">@</span>(<span class="dt">ForAll</span> bs2 _) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb41-3" data-line-number="3">    <span class="kw">let</span> <span class="dt">ForAll</span> as1 tau1 <span class="fu">=</span> renameBoundT [freeTypeVars t2] bs1 t1</a>
<a class="sourceLine" id="cb41-4" data-line-number="4">    <span class="kw">let</span> <span class="dt">ForAll</span> as2 tau2 <span class="fu">=</span> renameBoundT [freeTypeVars t1] bs2 t2</a>
<a class="sourceLine" id="cb41-5" data-line-number="5">    (s,_) <span class="ot">&lt;-</span> unifyTypesInContext (tau1, as1) (tau2, as2)</a>
<a class="sourceLine" id="cb41-6" data-line-number="6">    return s</a></code></pre></div>
<p>In addition to the generated tests for unification, here are some specific test cases that came up in debugging.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" data-line-number="1"><span class="ot">test_cases_unify_polytype ::</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb42-2" data-line-number="2">test_cases_unify_polytype <span class="fu">=</span> and</a></code></pre></div>
<p>First we have the signature of the identity function, written with two different dummy variables. These should unify with the empty substitution.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" data-line-number="1">  [ <span class="kw">let</span></a>
<a class="sourceLine" id="cb43-2" data-line-number="2">      x <span class="fu">=</span> <span class="dt">ForAll</span> (S.fromList [<span class="dt">Var</span> <span class="st">&quot;x0&quot;</span>])</a>
<a class="sourceLine" id="cb43-3" data-line-number="3">        (<span class="dt">TArr</span> <span class="dt">Q</span> (<span class="dt">TVar</span> <span class="dt">Q</span> (<span class="dt">Var</span> <span class="st">&quot;x0&quot;</span>)) (<span class="dt">TVar</span> <span class="dt">Q</span> (<span class="dt">Var</span> <span class="st">&quot;x0&quot;</span>)))</a>
<a class="sourceLine" id="cb43-4" data-line-number="4">      y <span class="fu">=</span> <span class="dt">ForAll</span> (S.fromList [<span class="dt">Var</span> <span class="st">&quot;x1&quot;</span>])</a>
<a class="sourceLine" id="cb43-5" data-line-number="5">        (<span class="dt">TArr</span> <span class="dt">Q</span> (<span class="dt">TVar</span> <span class="dt">Q</span> (<span class="dt">Var</span> <span class="st">&quot;x1&quot;</span>)) (<span class="dt">TVar</span> <span class="dt">Q</span> (<span class="dt">Var</span> <span class="st">&quot;x1&quot;</span>)))</a>
<a class="sourceLine" id="cb43-6" data-line-number="6">    <span class="kw">in</span></a>
<a class="sourceLine" id="cb43-7" data-line-number="7">      (<span class="fu">==</span>)</a>
<a class="sourceLine" id="cb43-8" data-line-number="8">        (unifyTypes x y)</a>
<a class="sourceLine" id="cb43-9" data-line-number="9">        (<span class="dt">Right</span> <span class="fu">$</span> <span class="dt">Sub</span> (M.fromList []))</a></code></pre></div>
<p>Next we have the signatures of two specialized identity functions; one on <span class="math inline">\(x_0\)</span> and one on <span class="math inline">\(x_1\)</span>. These should unify via the substitution taking <span class="math inline">\(x_0\)</span> to <span class="math inline">\(x_1\)</span>.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" data-line-number="1">  , <span class="kw">let</span></a>
<a class="sourceLine" id="cb44-2" data-line-number="2">      x <span class="fu">=</span> <span class="dt">ForAll</span> (S.fromList [])</a>
<a class="sourceLine" id="cb44-3" data-line-number="3">        (<span class="dt">TArr</span> <span class="dt">Q</span> (<span class="dt">TVar</span> <span class="dt">Q</span> (<span class="dt">Var</span> <span class="st">&quot;x0&quot;</span>)) (<span class="dt">TVar</span> <span class="dt">Q</span> (<span class="dt">Var</span> <span class="st">&quot;x0&quot;</span>)))</a>
<a class="sourceLine" id="cb44-4" data-line-number="4">      y <span class="fu">=</span> <span class="dt">ForAll</span> (S.fromList [])</a>
<a class="sourceLine" id="cb44-5" data-line-number="5">        (<span class="dt">TArr</span> <span class="dt">Q</span> (<span class="dt">TVar</span> <span class="dt">Q</span> (<span class="dt">Var</span> <span class="st">&quot;x1&quot;</span>)) (<span class="dt">TVar</span> <span class="dt">Q</span> (<span class="dt">Var</span> <span class="st">&quot;x1&quot;</span>)))</a>
<a class="sourceLine" id="cb44-6" data-line-number="6">    <span class="kw">in</span></a>
<a class="sourceLine" id="cb44-7" data-line-number="7">      (<span class="fu">==</span>)</a>
<a class="sourceLine" id="cb44-8" data-line-number="8">        (unifyTypes x y)</a>
<a class="sourceLine" id="cb44-9" data-line-number="9">        (<span class="dt">Right</span> <span class="fu">$</span> <span class="dt">Sub</span> (M.fromList [(<span class="dt">Var</span> <span class="st">&quot;x0&quot;</span>, <span class="dt">TVar</span> <span class="dt">Q</span> (<span class="dt">Var</span> <span class="st">&quot;x1&quot;</span>))]))</a></code></pre></div>
<p>The next example should fail to unify; in this case we have a free variable being captured. Namely <span class="math inline">\(w\)</span>.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb45-1" data-line-number="1">  , <span class="kw">let</span></a>
<a class="sourceLine" id="cb45-2" data-line-number="2">      x <span class="fu">=</span> <span class="dt">ForAll</span> (S.fromList [<span class="dt">Var</span> <span class="st">&quot;x0&quot;</span>])</a>
<a class="sourceLine" id="cb45-3" data-line-number="3">        (<span class="dt">TArr</span> <span class="dt">Q</span> (<span class="dt">TVar</span> <span class="dt">Q</span> (<span class="dt">Var</span> <span class="st">&quot;x0&quot;</span>)) (<span class="dt">TVar</span> <span class="dt">Q</span> (<span class="dt">Var</span> <span class="st">&quot;x0&quot;</span>)))</a>
<a class="sourceLine" id="cb45-4" data-line-number="4">      y <span class="fu">=</span> <span class="dt">ForAll</span> (S.fromList [<span class="dt">Var</span> <span class="st">&quot;x1&quot;</span>])</a>
<a class="sourceLine" id="cb45-5" data-line-number="5">        (<span class="dt">TArr</span> <span class="dt">Q</span> (<span class="dt">TVar</span> <span class="dt">Q</span> (<span class="dt">Var</span> <span class="st">&quot;x1&quot;</span>)) (<span class="dt">TVar</span> <span class="dt">Q</span> (<span class="dt">Var</span> <span class="st">&quot;w&quot;</span>)))</a>
<a class="sourceLine" id="cb45-6" data-line-number="6">    <span class="kw">in</span></a>
<a class="sourceLine" id="cb45-7" data-line-number="7">      (<span class="fu">==</span>)</a>
<a class="sourceLine" id="cb45-8" data-line-number="8">        (unifyTypes x y)</a>
<a class="sourceLine" id="cb45-9" data-line-number="9">        (<span class="dt">Left</span> <span class="fu">$</span> <span class="dt">FreeVariableCapture</span> (<span class="dt">Var</span> <span class="st">&quot;x1&quot;</span>))</a></code></pre></div>
<p>In the final example, we have one bound variable being matched to two others, which fails to unify.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb46-1" data-line-number="1">  , <span class="kw">let</span></a>
<a class="sourceLine" id="cb46-2" data-line-number="2">      x <span class="fu">=</span> <span class="dt">ForAll</span> (S.fromList [<span class="dt">Var</span> <span class="st">&quot;x0&quot;</span>])</a>
<a class="sourceLine" id="cb46-3" data-line-number="3">        (<span class="dt">TArr</span> <span class="dt">Q</span> (<span class="dt">TVar</span> <span class="dt">Q</span> (<span class="dt">Var</span> <span class="st">&quot;x0&quot;</span>)) (<span class="dt">TVar</span> <span class="dt">Q</span> (<span class="dt">Var</span> <span class="st">&quot;x0&quot;</span>)))</a>
<a class="sourceLine" id="cb46-4" data-line-number="4">      y <span class="fu">=</span> <span class="dt">ForAll</span> (S.fromList [<span class="dt">Var</span> <span class="st">&quot;x0&quot;</span>, <span class="dt">Var</span> <span class="st">&quot;x1&quot;</span>])</a>
<a class="sourceLine" id="cb46-5" data-line-number="5">        (<span class="dt">TArr</span> <span class="dt">Q</span> (<span class="dt">TVar</span> <span class="dt">Q</span> (<span class="dt">Var</span> <span class="st">&quot;x1&quot;</span>)) (<span class="dt">TVar</span> <span class="dt">Q</span> (<span class="dt">Var</span> <span class="st">&quot;x0&quot;</span>)))</a>
<a class="sourceLine" id="cb46-6" data-line-number="6">    <span class="kw">in</span></a>
<a class="sourceLine" id="cb46-7" data-line-number="7">      (<span class="fu">==</span>)</a>
<a class="sourceLine" id="cb46-8" data-line-number="8">        (unifyTypes x y)</a>
<a class="sourceLine" id="cb46-9" data-line-number="9">        (<span class="dt">Left</span> <span class="dt">IncompatibleSub</span>)</a>
<a class="sourceLine" id="cb46-10" data-line-number="10">  ]</a></code></pre></div>
<p>In the next section we will see how to assign types to lambda expressions.</p>
</body>
</html>
